{"ast":null,"code":"/* eslint-disable no-param-reassign */\nvar index = function index(breakpoints) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    literal = _ref.literal,\n    overlap = _ref.overlap;\n  var mq = literal ? breakpoints : ['&'].concat(breakpoints);\n  function flatten(obj) {\n    if (typeof obj !== 'object' || obj == null) {\n      return [];\n    }\n    if (Array.isArray(obj)) {\n      return obj.map(flatten);\n    }\n    var slots = {};\n    var objects = {};\n    var props = {};\n    Object.keys(obj).forEach(function (key) {\n      // Check if value is an array, but skip if it looks like a selector.\n      // key.indexOf('&') === 0\n\n      var item = obj[key];\n      if (!Array.isArray(item) && literal) item = [item];\n      if ((literal || Array.isArray(item)) && key.charCodeAt(0) !== 38) {\n        var prior = void 0;\n        item.forEach(function (v, index) {\n          // Optimize by removing duplicated media query entries\n          // when they are explicitly known to overlap.\n          if (overlap && prior === v) {\n            return;\n          }\n          if (v == null) {\n            // Do not create entries for undefined values as this will\n            // generate empty media media quries\n            return;\n          }\n          prior = v;\n          if (index === 0 && !literal) {\n            props[key] = v;\n          } else if (slots[mq[index]] === undefined) {\n            var _slots$mq$index;\n            slots[mq[index]] = (_slots$mq$index = {}, _slots$mq$index[key] = v, _slots$mq$index);\n          } else {\n            slots[mq[index]][key] = v;\n          }\n        });\n      } else if (typeof item === 'object') {\n        objects[key] = flatten(item);\n      } else {\n        props[key] = item;\n      }\n    });\n\n    // Ensure that all slots and then child objects are pushed to the end\n    mq.forEach(function (el) {\n      if (slots[el]) {\n        props[el] = slots[el];\n      }\n    });\n    Object.assign(props, objects);\n    return props;\n  }\n  return function () {\n    for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n    return values.map(flatten);\n  };\n};\nexport default index;","map":{"version":3,"mappings":"AAAA;AACA,YAAe,SAAfA,MAAwBC,WAAT,EAAiD;iFAAJ,EAAI;IAAzBC,OAAyB,QAAzBA,OAAyB;IAAhBC,OAAgB,QAAhBA,OAAgB;MACxDC,KAAKF,UAAUD,WAAV,GAAwB,CAAC,GAAD,EAAMI,MAAN,CAAaJ,WAAb,CAAnC;WAESK,OAAT,CAAiBC,GAAjB,EAAsB;QAChB,OAAOA,GAAP,KAAe,QAAf,IAA2BA,OAAO,IAAtC,EAA4C;aACnC,EAAP;;QAGEC,MAAMC,OAAN,CAAcF,GAAd,CAAJ,EAAwB;aACfA,IAAIG,GAAJ,CAAQJ,OAAR,CAAP;;QAGIK,QAAQ,EAAd;QACMC,UAAU,EAAhB;QACMC,QAAQ,EAAd;WACOC,IAAP,CAAYP,GAAZ,EAAiBQ,OAAjB,CAAyB,eAAO;;;;UAI1BC,OAAOT,IAAIU,GAAJ,CAAX;UACI,CAACT,MAAMC,OAAN,CAAcO,IAAd,CAAD,IAAwBd,OAA5B,EAAqCc,OAAO,CAACA,IAAD,CAAP;UAEjC,CAACd,WAAWM,MAAMC,OAAN,CAAcO,IAAd,CAAZ,KAAoCC,IAAIC,UAAJ,CAAe,CAAf,MAAsB,EAA9D,EAAkE;YAC5DC,cAAJ;aACKJ,OAAL,CAAa,UAACK,CAAD,EAAIpB,KAAJ,EAAc;;;cAGrBG,WAAWgB,UAAUC,CAAzB,EAA4B;;;cAIxBA,KAAK,IAAT,EAAe;;;;;kBAMPA,CAAR;cAEIpB,UAAU,CAAV,IAAe,CAACE,OAApB,EAA6B;kBACrBe,GAAN,IAAaG,CAAb;WADF,MAEO,IAAIT,MAAMP,GAAGJ,KAAH,CAAN,MAAqBqB,SAAzB,EAAoC;;kBACnCjB,GAAGJ,KAAH,CAAN,2CAAsBiB,GAAtB,IAA4BG,CAA5B;WADK,MAEA;kBACChB,GAAGJ,KAAH,CAAN,EAAiBiB,GAAjB,IAAwBG,CAAxB;;SApBJ;OAFF,MAyBO,IAAI,OAAOJ,IAAP,KAAgB,QAApB,EAA8B;gBAC3BC,GAAR,IAAeX,QAAQU,IAAR,CAAf;OADK,MAEA;cACCC,GAAN,IAAaD,IAAb;;KAnCJ;;;OAwCGD,OAAH,CAAW,cAAM;UACXJ,MAAMW,EAAN,CAAJ,EAAe;cACPA,EAAN,IAAYX,MAAMW,EAAN,CAAZ;;KAFJ;WAKOC,MAAP,CAAcV,KAAd,EAAqBD,OAArB;WACOC,KAAP;;SAGK;sCAAIW,MAAJ;YAAA;;WAAeA,OAAOd,GAAP,CAAWJ,OAAX,CAAf;GAAP","names":["index","breakpoints","literal","overlap","mq","concat","flatten","obj","Array","isArray","map","slots","objects","props","keys","forEach","item","key","charCodeAt","prior","v","undefined","el","assign","values"],"sources":["/Users/marielsgtzz/Desktop/WebDev/React/React-fundamentals/node_modules/facepaint/src/index.js"],"sourcesContent":["/* eslint-disable no-param-reassign */\nexport default function(breakpoints, { literal, overlap } = {}) {\n  const mq = literal ? breakpoints : ['&'].concat(breakpoints)\n\n  function flatten(obj) {\n    if (typeof obj !== 'object' || obj == null) {\n      return []\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(flatten)\n    }\n\n    const slots = {}\n    const objects = {}\n    const props = {}\n    Object.keys(obj).forEach(key => {\n      // Check if value is an array, but skip if it looks like a selector.\n      // key.indexOf('&') === 0\n\n      let item = obj[key]\n      if (!Array.isArray(item) && literal) item = [item]\n\n      if ((literal || Array.isArray(item)) && key.charCodeAt(0) !== 38) {\n        let prior\n        item.forEach((v, index) => {\n          // Optimize by removing duplicated media query entries\n          // when they are explicitly known to overlap.\n          if (overlap && prior === v) {\n            return\n          }\n\n          if (v == null) {\n            // Do not create entries for undefined values as this will\n            // generate empty media media quries\n            return\n          }\n\n          prior = v\n\n          if (index === 0 && !literal) {\n            props[key] = v\n          } else if (slots[mq[index]] === undefined) {\n            slots[mq[index]] = { [key]: v }\n          } else {\n            slots[mq[index]][key] = v\n          }\n        })\n      } else if (typeof item === 'object') {\n        objects[key] = flatten(item)\n      } else {\n        props[key] = item\n      }\n    })\n\n    // Ensure that all slots and then child objects are pushed to the end\n    mq.forEach(el => {\n      if (slots[el]) {\n        props[el] = slots[el];\n      }\n    })\n    Object.assign(props, objects)\n    return props\n  }\n\n  return (...values) => values.map(flatten)\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}