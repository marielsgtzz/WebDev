{"ast":null,"code":"/**\r\n * Converts a string path to a Regular Expression.\r\n * Transforms path parameters into named RegExp groups.\r\n */\nvar pathToRegExp = function pathToRegExp(path) {\n  var pattern = path\n  // Escape literal dots\n  .replace(/\\./g, '\\\\.')\n  // Escape literal slashes\n  .replace(/\\//g, '/')\n  // Escape literal question marks\n  .replace(/\\?/g, '\\\\?')\n  // Ignore trailing slashes\n  .replace(/\\/+$/, '')\n  // Replace wildcard with any zero-to-any character sequence\n  .replace(/\\*+/g, '.*')\n  // Replace parameters with named capturing groups\n  .replace(/:([^\\d|^\\/][a-zA-Z0-9_]*(?=(?:\\/|\\\\.)|$))/g, function (_, paramName) {\n    return \"(?<\".concat(paramName, \">[^/]+?)\");\n  })\n  // Allow optional trailing slash\n  .concat('(\\\\/|$)');\n  return new RegExp(pattern, 'gi');\n};\n\n/**\r\n * Matches a given url against a path.\r\n */\nvar match = function match(path, url) {\n  var expression = path instanceof RegExp ? path : pathToRegExp(path);\n  var match = expression.exec(url) || false;\n  // Matches in strict mode: match string should equal to input (url)\n  // Otherwise loose matches will be considered truthy:\n  // match('/messages/:id', '/messages/123/users') // true\n  var matches = path instanceof RegExp ? !!match : !!match && match[0] === match.input;\n  return {\n    matches: matches,\n    params: match && matches ? match.groups || null : null\n  };\n};\nexport { match, pathToRegExp };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["/**\r\n * Converts a string path to a Regular Expression.\r\n * Transforms path parameters into named RegExp groups.\r\n */\r\nconst pathToRegExp = (path) => {\r\n    const pattern = path\r\n        // Escape literal dots\r\n        .replace(/\\./g, '\\\\.')\r\n        // Escape literal slashes\r\n        .replace(/\\//g, '/')\r\n        // Escape literal question marks\r\n        .replace(/\\?/g, '\\\\?')\r\n        // Ignore trailing slashes\r\n        .replace(/\\/+$/, '')\r\n        // Replace wildcard with any zero-to-any character sequence\r\n        .replace(/\\*+/g, '.*')\r\n        // Replace parameters with named capturing groups\r\n        .replace(/:([^\\d|^\\/][a-zA-Z0-9_]*(?=(?:\\/|\\\\.)|$))/g, (_, paramName) => `(?<${paramName}>[^\\/]+?)`)\r\n        // Allow optional trailing slash\r\n        .concat('(\\\\/|$)');\r\n    return new RegExp(pattern, 'gi');\r\n};\n\n/**\r\n * Matches a given url against a path.\r\n */\r\nconst match = (path, url) => {\r\n    const expression = path instanceof RegExp ? path : pathToRegExp(path);\r\n    const match = expression.exec(url) || false;\r\n    // Matches in strict mode: match string should equal to input (url)\r\n    // Otherwise loose matches will be considered truthy:\r\n    // match('/messages/:id', '/messages/123/users') // true\r\n    const matches = path instanceof RegExp ? !!match : !!match && match[0] === match.input;\r\n    return {\r\n        matches,\r\n        params: match && matches ? match.groups || null : null,\r\n    };\r\n};\n\nexport { match, pathToRegExp };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}